#ui
ui <- fluidPage(
selectInput(
inputId="pvselection",
label = "Select p-Value",
choices = c("p<0.05" = 1.30103, "p<0.01" = 2),
selected =  1.3013,
multiple = FALSE
),
selectInput(
inputId="fcselection",
label = "Select fold change",
choices = c("4" = 0.60206, "2" = 0.30103),
selected =  0.30103,
multiple = FALSE
),
plotOutput("volcano")
)
#server
server <- function(input, output)
{
output$volcano <- renderPlot(
{
library("shiny")
mydata <- read.delim("diffexp-myc.txt", sep="\t", header = T)
#load log-foldchange and pvalue from the data.frame
LogFC <- mydata$logFC_WB1PMyc_Ctrl
pValue <- mydata$adj.P.Val_WB1PMyc_Ctrl
#log10
negLogPV <- -log10(pValue)
pvselection <- input$pvselection
fcselection <- input$fcselection
#add PV-FALSE/TRUE row
pvSelectionCol <- as.factor(negLogPV > pvselection)
fcSelectionCol <- as.factor((LogFC > fcselection | LogFC < -fcselection))
bothPostitionCol <- as.factor(((negLogPV > pvselection & (LogFC > fcselection | LogFC <  -fcselection))))
#genrate datafram
df <- cbind(cbind(  data.frame(cbind(LogFC,negLogPV)),
pvSelectionCol,
fcSelectionCol,
bothPostitionCol
))
plot(df$LogFC, df$negLogPV, col=c("gray", "blue")[df$bothPostitionCol], xlab="Log10 Fold Change", ylab="Negative Log10 p-value", main="Foldchange vs p-Value")
#xyplot(df$negLogPV~df$LogFC, col=c("gray", "green")[df$bothPostitionCol])
#add lines
abline(v=c(-fcselection,fcselection), col=c("red", "red"), lty=c(2,2), lwd=c(1,1))
abline(h=pvselection, col="black", lty=2, lwd=1)
}
)
}
#shinyAPP
shinyApp(ui=ui, server=server)
#ui
ui <- fluidPage(
selectInput(
inputId="pvselection",
label = "Select p-Value",
choices = c("p<0.05" = 1.30103, "p<0.01" = 2),
selected =  1.3013,
multiple = FALSE
),
selectInput(
inputId="fcselection",
label = "Select fold change",
choices = c("2" = 0.30103, "4" = 0.60206),
selected =  0.30103,
multiple = FALSE
),
plotOutput("volcano")
)
#server
server <- function(input, output)
{
library("shiny")
mydata <- read.delim("diffexp-myc.txt", sep="\t", header = T)
#load log-foldchange and pvalue from the data.frame
LogFC <- mydata$logFC_WB1PMyc_Ctrl
pValue <- mydata$adj.P.Val_WB1PMyc_Ctrl
#log10
negLogPV <- -log10(pValue)
pvselection <- input$pvselection
fcselection <- input$fcselection
#add PV-FALSE/TRUE row
pvSelectionCol <- as.factor(negLogPV >= pvselection)
fcSelectionCol <- as.factor((LogFC >= fcselection | LogFC <= -fcselection))
bothPostitionCol <- as.factor(((negLogPV >= pvselection & (LogFC >= fcselection | LogFC <=  -fcselection))))
#genrate datafram
df <- cbind(cbind(  data.frame(cbind(LogFC,negLogPV)),
pvSelectionCol,
fcSelectionCol,
bothPostitionCol
))
output$volcano <- renderPlot(
{
plot(df$LogFC, df$negLogPV, col=c("gray", "blue")[df$bothPostitionCol], xlab="Log10 Fold Change", ylab="Negative Log10 p-value", main="Foldchange vs p-Value")
#xyplot(df$negLogPV~df$LogFC, col=c("gray", "green")[df$bothPostitionCol])
#add lines
abline(v=c(-fcselection,fcselection), col=c("red", "red"), lty=c(2,2), lwd=c(1,1))
abline(h=pvselection, col="black", lty=2, lwd=1)
}
)
}
#shinyAPP
shinyApp(ui=ui, server=server)
#ui
ui <- fluidPage(
selectInput(
inputId="pvselection",
label = "Select p-Value",
choices = c("p<0.05" = 1.30103, "p<0.01" = 2),
selected =  1.3013,
multiple = FALSE
),
selectInput(
inputId="fcselection",
label = "Select fold change",
choices = c("2" = 0.30103, "4" = 0.60206),
selected =  0.30103,
multiple = FALSE
),
plotOutput("volcano")
)
#server
server <- function(input, output)
{
library("shiny")
mydata <- read.delim("diffexp-myc.txt", sep="\t", header = T)
#load log-foldchange and pvalue from the data.frame
LogFC <- mydata$logFC_WB1PMyc_Ctrl
pValue <- mydata$adj.P.Val_WB1PMyc_Ctrl
#log10
negLogPV <- -log10(pValue)
pvselection <- input$pvselection
fcselection <- input$fcselection
#add PV-FALSE/TRUE row
pvSelectionCol <- as.factor(negLogPV >= pvselection)
fcSelectionCol <- as.factor((LogFC >= fcselection | LogFC <= -fcselection))
bothPostitionCol <- as.factor(((negLogPV >= pvselection & (LogFC >= fcselection | LogFC <=  -fcselection))))
#genrate datafram
df <- cbind(cbind(  data.frame(cbind(LogFC,negLogPV)),
pvSelectionCol,
fcSelectionCol,
bothPostitionCol
))
output$volcano <- renderPlot(
{
plot(df$LogFC, df$negLogPV, col=c("gray", "blue")[df$bothPostitionCol], xlab="Log10 Fold Change", ylab="Negative Log10 p-value", main="Foldchange vs p-Value")
#xyplot(df$negLogPV~df$LogFC, col=c("gray", "green")[df$bothPostitionCol])
#add lines
abline(v=c(-fcselection,fcselection), col=c("red", "red"), lty=c(2,2), lwd=c(1,1))
abline(h=pvselection, col="black", lty=2, lwd=1)
}
)
}
#shinyAPP
shinyApp(ui=ui, server=server)
#ui
ui <- fluidPage(
selectInput(
inputId="pvselection",
label = "Select p-Value",
choices = c("p<0.05" = 1.30103, "p<0.01" = 2),
selected =  1.3013,
multiple = FALSE
),
selectInput(
inputId="fcselection",
label = "Select fold change",
choices = c("2" = 0.30103, "4" = 0.60206),
selected =  0.30103,
multiple = FALSE
),
plotOutput("volcano")
)
#server
server <- function(input, output)
{
library("shiny")
mydata <- read.delim("diffexp-myc.txt", sep="\t", header = T)
#load log-foldchange and pvalue from the data.frame
LogFC <- mydata$logFC_WB1PMyc_Ctrl
pValue <- mydata$adj.P.Val_WB1PMyc_Ctrl
#log10
negLogPV <- -log10(pValue)
pvselection <- input$pvselection
fcselection <- input$fcselection
#add PV-FALSE/TRUE row
pvSelectionCol <- as.factor(negLogPV >= pvselection)
fcSelectionCol <- as.factor((LogFC >= fcselection | LogFC <= -fcselection))
bothPostitionCol <- as.factor(((negLogPV >= pvselection & (LogFC >= fcselection | LogFC <=  -fcselection))))
#genrate datafram
df <- cbind(cbind(  data.frame(cbind(LogFC,negLogPV)),
pvSelectionCol,
fcSelectionCol,
bothPostitionCol
))
output$volcano <- renderPlot(
{
plot(df$LogFC, df$negLogPV, col=c("gray", "blue")[df$bothPostitionCol], xlab="Log10 Fold Change", ylab="Negative Log10 p-value", main="Foldchange vs p-Value")
#xyplot(df$negLogPV~df$LogFC, col=c("gray", "green")[df$bothPostitionCol])
#add lines
abline(v=c(-fcselection,fcselection), col=c("red", "red"), lty=c(2,2), lwd=c(1,1))
abline(h=pvselection, col="black", lty=2, lwd=1)
}
)
}
#shinyAPP
shinyApp(ui=ui, server=server)
df
View(df)
View(df)
View(df)
View(df)
a <- subset(df, df[5] == "TRUE")
a
a <- subset(df, bothPostitionCol == "TRUE")
a
shiny::runApp('Volcano')
View(df)
View(df)
rPlot(LogFC ~ negLogPV, data=df, type='point')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
View(df)
View(df)
rPlot(LogFC ~ NegLogPV, data=df, type='point')
rPlot(LogFC ~ negLogPV, data=df, type='point')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
View(df)
rPlot(LogFC ~ negLogPV, data=df, type='point')
rPlot(LogFC ~ negLogPV | bothPostitionCol, data=df, type='point')
?nPlot
?nPlot()
?nPlot
shiny::runApp('Volcano')
shiny::runApp('Volcano')
?showOutput
shiny::runApp('Volcano')
libPaths()
.libPaths()
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
library("rCharts", lib.loc="D:/Apps/R-3.2.1/library")
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
ls
df
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
View(df)
View(df)
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shinyApp(ui, server)
library("shiny", lib.loc="D:/Apps/R-3.2.1/library")
#app.R#
library(shiny)
createLink <- function(val) {
sprintf('<a href="https://www.google.com/#q=%s" target="_blank" class="btn btn-primary">Info</a>',val)
}
ui <- fluidPage(
titlePanel("Table with Links!"),
sidebarLayout(
sidebarPanel(
h4("Click the link in the table to see
a google search for the car.")
),
mainPanel(
dataTableOutput('table1')
)
)
)
server <- function(input, output) {
output$table1 <- renderDataTable({
my_table <- cbind(rownames(mtcars), mtcars)
colnames(my_table)[1] <- 'car'
my_table$link <- createLink(my_table$car)
return(my_table)
}, escape = FALSE)
}
shinyApp(ui, server)
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
## Only run this example in interactive R sessions
if (interactive()) {
# pass a callback function to DataTables using I()
shinyApp(
ui = fluidPage(
fluidRow(
column(12,
dataTableOutput('table')
)
)
),
server = function(input, output) {
output$table <- renderDataTable(iris,
options = list(
pageLength = 5,
initComplete = I("function(settings, json) {alert('Done.');}")
)
)
}
)
}
shiny::runApp('Volcano')
ui = fluidPage(
library(shiny)
library(ggplot2)  # for the diamonds dataset
shinyUI(pageWithSidebar(
headerPanel('Examples of DataTables'),
sidebarPanel(
checkboxGroupInput('show_vars', 'Columns in diamonds to show:', names(diamonds),
selected = names(diamonds)),
helpText('For the diamonds data, we can select variables to show in the table;
for the mtcars example, we use orderClasses = TRUE so that sorted
columns are colored since they have special CSS classes attached;
for the iris data, we customize the length menu so we can display 5
rows per page.')
),
mainPanel(
tabsetPanel(
tabPanel('diamonds',
dataTableOutput("mytable1")),
tabPanel('mtcars',
dataTableOutput("mytable2")),
tabPanel('iris',
dataTableOutput("mytable3"))
)
)
))
library(shiny)
shinyServer(function(input, output) {
# a large table, reative to input$show_vars
output$mytable1 = renderDataTable({
library(ggplot2)
diamonds[, input$show_vars, drop = FALSE]
})
# sorted columns are colored now because CSS are attached to them
output$mytable2 = renderDataTable({
mtcars
}, options = list(orderClasses = TRUE))
# customize the length drop-down menu; display 5 rows per page by default
output$mytable3 = renderDataTable({
iris
}, options = list(lengthMenu = c(5, 30, 50), pageLength = 5))
})
)
shinyApp(
ui = fluidPage(
library(shiny)
library(ggplot2)  # for the diamonds dataset
shinyUI(pageWithSidebar(
headerPanel('Examples of DataTables'),
sidebarPanel(
checkboxGroupInput('show_vars', 'Columns in diamonds to show:', names(diamonds),
selected = names(diamonds)),
helpText('For the diamonds data, we can select variables to show in the table;
for the mtcars example, we use orderClasses = TRUE so that sorted
columns are colored since they have special CSS classes attached;
for the iris data, we customize the length menu so we can display 5
rows per page.')
),
mainPanel(
tabsetPanel(
tabPanel('diamonds',
dataTableOutput("mytable1")),
tabPanel('mtcars',
dataTableOutput("mytable2")),
tabPanel('iris',
dataTableOutput("mytable3"))
)
)
))
)
shinyServer(function(input, output) {
# a large table, reative to input$show_vars
output$mytable1 = renderDataTable({
library(ggplot2)
diamonds[, input$show_vars, drop = FALSE]
})
# sorted columns are colored now because CSS are attached to them
output$mytable2 = renderDataTable({
mtcars
}, options = list(orderClasses = TRUE))
# customize the length drop-down menu; display 5 rows per page by default
output$mytable3 = renderDataTable({
iris
}, options = list(lengthMenu = c(5, 30, 50), pageLength = 5))
})
)
shinyApp(
ui = fluidPage(
library(shiny)
library(ggplot2)  # for the diamonds dataset
shinyUI(pageWithSidebar(
headerPanel('Examples of DataTables'),
sidebarPanel(
checkboxGroupInput('show_vars', 'Columns in diamonds to show:', names(diamonds),
selected = names(diamonds)),
helpText('For the diamonds data, we can select variables to show in the table;
for the mtcars example, we use orderClasses = TRUE so that sorted
columns are colored since they have special CSS classes attached;
for the iris data, we customize the length menu so we can display 5
rows per page.')
),
mainPanel(
tabsetPanel(
tabPanel('diamonds',
dataTableOutput("mytable1")),
tabPanel('mtcars',
dataTableOutput("mytable2")),
tabPanel('iris',
dataTableOutput("mytable3"))
)
)
))
)
shinyServer(function(input, output) {
# a large table, reative to input$show_vars
output$mytable1 = renderDataTable({
library(ggplot2)
diamonds[, input$show_vars, drop = FALSE]
})
# sorted columns are colored now because CSS are attached to them
output$mytable2 = renderDataTable({
mtcars
}, options = list(orderClasses = TRUE))
# customize the length drop-down menu; display 5 rows per page by default
output$mytable3 = renderDataTable({
iris
}, options = list(lengthMenu = c(5, 30, 50), pageLength = 5))
})
)
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
hist(c(1,2,3))
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
install.packages("shinyjs")
library("shinyjs", lib.loc="D:/Apps/R-3.2.1/library")
library("shiny", lib.loc="D:/Apps/R-3.2.1/library")
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
a <- "LogFC"
df[a]
df[a,1]
df[,a]
df[a]
df[,a]
df[a,]
length(df[,a])
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
shiny::runApp('Volcano')
